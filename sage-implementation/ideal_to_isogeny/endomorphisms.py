from sage.all import (
    randint,
    EllipticCurve,
    floor,
    sqrt,
    ZZ, gcd, 
    factor, 
    log
)

import sys
sys.path.insert(0, '..')
from applications.PRISM.utilities.sum_of_squares import sum_of_squares
# from applications.utilities.logging_helper import logging
import time
from utilities.pairing import tate_pairing_power_two, weil_pairing_pari

# logger = logging.getLogger(__name__)

def FullrepresentInteger(M, p, TrulyRandom = True, primitive = False):
    r"""
    Given an integer M >p, it finds a, b, c, d such that
    N(a + b *i  + c *j + d * k) == M

    TrulyRandom is set as True by default.
    Set it to False to add some conditions, made to avoid diagonal isogenies in FixedDegree

    References: [DLLW23, Alg 1]
    """
    assert M > p
    init_time = time.time()
    four_Mp = 4 * M / p
    mp = floor(sqrt(four_Mp))
    count = 0
    while True:
        z = randint(-mp, mp)
        mpp = floor(sqrt(four_Mp - z ** 2))
        t = randint(-mpp, mpp)
        Mp = 4 * M - p * (z ** 2 + t ** 2)
        sol = sum_of_squares(Mp)
        count += 1
        if sol != []:
            x, y = sol
            x, y = ZZ(x), ZZ(y)
            if (x - t)%2 == 0 and (z - y)%2 == 0:
                if (not primitive) or gcd([(x-t)//2,(y-z)//2,z,t])==1:
                    if TrulyRandom:
                        break
                    else:
                        if ((x-t)//2)%2 == 1 and ((z-y)//2)%2 ==1:
                            break
    #NB: (x+yi+zj+tk)/2 represents the element
    # (x', y', z', t') in O0 with z'=z, t'=t, y'=(y-z)/2, x'=(x-t)/2

    # logger.debug2(f"FullRepresentInteger({ZZ(M).nbits()}b, TrulyRandom={TrulyRandom}, primitive={primitive}): {count} tries, {(time.time() - init_time):.3f}s")
    x, y, z, t = ZZ(x)/ZZ(2), ZZ(y)/ZZ(2), ZZ(z)/ZZ(2), ZZ(t)/ZZ(2)
    return x, y, z, t


def iota(P):
    F = P.base_ring()
    E = P.curve()
    # Ensure we're on the right curve
    assert E == EllipticCurve(F, [1, 0])

    # Ensure the gen is sqrt -1
    i = F.gen()
    assert i**2 == -1

    return E(-P[0], i * P[1], P[2])


def pi(P):
    F = P.base_ring()
    E = P.curve()

    # Ensure we're on the right curve
    assert E == EllipticCurve(F, [1, 0])

    p = F.characteristic()
    return E(P[0] ** p, P[1] ** p, P[2] ** p)

def check_endomorphism(P1, P2, Q1, Q2):
    r"""
    We are given a (2,2)-kernel <(P1, P2), (Q1, Q2)>.
    The functions checks whether this kernel correspond to an endomorphism on E0 x E0
    """
    if (P1 == P2) and (Q1 == Q2):
        return 1

    if (iota(P1) == P2) and (iota(Q1) == Q2):
        return 2

    return False

def evaluate_endomorphism_type(type_end, T1, T2):
    r"""
    #Given the type of endomorphism, this function evaluates
    #the endomorphism at (T1, T2)
    """
    if type_end == 1:
        return T1 + T2, T1 - T2
    else:
        iota_T1 = iota(T1)
        return iota_T1 + T2, iota_T1 - T2


def order_pairing(e):
    r"""
    TODO
    """
    eq_one = False
    ord = 0
    while not eq_one:
        ord += 1
        e = e ** 2
        eq_one = (e == 1)
    return ord 


def check_diagonal_isogeny(P1, P2, Q1, Q2, f):
    r"""

    TODO: modify the description

    Given a (2,2)-isogeny kernel, check whether it is the kernel of a diagonal isogeny
    this happens when one of the points is zero.

    INPUT: P1, P2, Q1, Q2, points such that (P1,P2), (Q1, Q2) is a basis of the kernel.

    OUTPUT:
    - is_diagonal: boolean value which is True if and only if the isogeny is diagonal;
    - R1, R2: if type>0, points such that the kernel is generated by (R1,0) and (0,R2).
    """


    ff = 2**(f-1)
    # From this pairing we can get the number of products we have to do 
    extra = weil_pairing_pari(P1, Q1, 2*ff)
    num_prods = f - order_pairing(extra)

    if num_prods == 0:
        return P1, P2, Q1, Q2, 0, 0
    else:
        w1 = weil_pairing_pari(P1, Q2, 2*ff)**ff
        w2 = weil_pairing_pari(P2, Q1, 2*ff)**ff
        if w1 == 1 and num_prods != 0:
            return Q1, P2, P1, Q2, 'Q', num_prods
        elif w2 == 1 and num_prods != 0:
            return P1, Q2, Q1, P2, 'P', num_prods
        # _P1 = 2**(f-1)*P1
        # _Q2 = 2**(f-1)*Q2
        # if _P1 == 0 or _Q2 == 0:
        #     return Q1, P2, P1, Q2, 'Q', num_prods
        # _P2 = 2**(f-1)*P2
        # _Q1 = 2**(f-1)*Q1
        # if _P2 == 0 or _Q1 == 0:
        #     return P1, Q2, Q1, P2, 'P', num_prods


def check_diagonal_isogeny_old(P1, P2, Q1, Q2):
    r"""
    Given a (2,2)-isogeny kernel, check whether it is the kernel of a diagonal isogeny
    this happens when one of the points is zero.

    INPUT: P1, P2, Q1, Q2, points such that (P1,P2), (Q1, Q2) is a basis of the kernel.

    OUTPUT:
    - is_diagonal: boolean value which is True if and only if the isogeny is diagonal;
    - R1, R2: if type>0, points such that the kernel is generated by (R1,0) and (0,R2).
    """

    if P1 == 0 or Q2 == 0:
        return True, Q1, P2
    elif P2 == 0 or Q1 == 0:
        return True, P1, Q2
    else:
        return False, 0, 0

def diagonal_isogeny(R1,R2):
	r"""
	Given the kernel of a diagonal (2,2)-isogeny f, returns the diagonal components of
	this isogeny.

	INPUT: R1, R2, points such that (R1,0) and (0,R2) generate the ker(f).

	OUTPUT: diagonal component isogenies phi1, phi2, such that:
	f: (P,Q) |--> (phi1(P),phi2(Q)).
	"""
	E1 = R1.curve()
	E2 = R2.curve()

	φ1 = E1.isogeny(R1, degree = 2, model = "montgomery")
	φ2 = E2.isogeny(R2, degree = 2, model = "montgomery")

	return φ1, φ2
